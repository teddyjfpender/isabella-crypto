{"code":"theory LatticeCrypto\n  imports Main \"HOL-Library.Code_Target_Numeral\"\nbegin\n\ntype_synonym int_vec = \"int list\"\ntype_synonym int_matrix = \"int list list\"\n\ndefinition dot :: \"int_vec => int_vec => int\" where\n  \"dot v w = sum_list (map2 (*) v w)\"\n\ndefinition mat_vec_mult :: \"int_matrix => int_vec => int_vec\" where\n  \"mat_vec_mult A v = map (%row. dot row v) A\"\n\ndefinition transpose :: \"int_matrix => int_matrix\" where\n  \"transpose A =\n     (let m = length A;\n          n = (if m = 0 then 0 else length (hd A))\n      in map (%j. map (%i. (A ! i) ! j) [0..<m]) [0..<n])\"\n\nrecord lwe_params =\n  lwe_n :: nat\n  lwe_q :: int\n\nrecord lwe_secret_key =\n  lwe_s :: int_vec\n\nrecord lwe_public_key =\n  lwe_A :: int_matrix\n  lwe_b :: int_vec\n\ndefinition encode_bit :: \"lwe_params => bool => int\" where\n  \"encode_bit params m = (if m then lwe_q params div 2 else 0)\"\n\ndefinition decode_bit :: \"lwe_params => int => bool\" where\n  \"decode_bit params v = (abs (v - lwe_q params div 2) < lwe_q params div 4)\"\n\ndefinition lwe_encrypt :: \"lwe_public_key => lwe_params => bool => int_vec => (int_vec * int)\" where\n  \"lwe_encrypt pk params m r =\n     (let u = mat_vec_mult (transpose (lwe_A pk)) r;\n          v = dot (lwe_b pk) r + encode_bit params m\n      in (u, v))\"\n\ndefinition lwe_decrypt :: \"lwe_secret_key => lwe_params => (int_vec * int) => bool\" where\n  \"lwe_decrypt sk params ct =\n     (let u = fst ct;\n          v = snd ct;\n          d = v - dot (lwe_s sk) u\n      in decode_bit params d)\"\n\ndefinition lwe_correctness_condition ::\n  \"lwe_params => lwe_public_key => lwe_secret_key => int_vec => bool => bool\" where\n  \"lwe_correctness_condition params pk sk r m =\n     (lwe_decrypt sk params (lwe_encrypt pk params m r) = m)\"\n\nlemma lwe_correctness_condition_lemma:\n  assumes \"lwe_correctness_condition params pk sk r m\"\n  shows \"lwe_decrypt sk params (lwe_encrypt pk params m r) = m\"\n  using assms unfolding lwe_correctness_condition_def by simp\n\nexport_code\n  dot mat_vec_mult transpose\n  encode_bit decode_bit\n  lwe_encrypt lwe_decrypt\n  lwe_correctness_condition\n  lwe_params.make lwe_n lwe_q\n  lwe_secret_key.make lwe_s\n  lwe_public_key.make lwe_A lwe_b\n  in Haskell module_name \"Lattice.LWE\"\n\nend\n","notes":"Used skills: isabelle-basics (theory structure), isabelle-proofs (complete simp proof), isabelle-datatypes (records), isabelle-code-generation (export_code), isabelle-lattice-crypto (LWE structure). The correctness condition is stated via a definitional predicate and a trivial lemma, as requested without a substantive proof."}
