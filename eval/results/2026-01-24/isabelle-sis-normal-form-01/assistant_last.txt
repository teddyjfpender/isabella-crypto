{"code": "theory LatticeCrypto\n  imports Main \"HOL-Library.Code_Target_Numeral\"\nbegin\n\ntype_synonym int_vec = \"int list\"\ntype_synonym int_matrix = \"int list list\"\n\nrecord sis_params =\n  n :: nat\n  m :: nat\n  q :: int\n  beta :: int\n\nrecord sis_instance =\n  A :: int_matrix\n  b :: int_vec\n\nrecord nf_sis_instance =\n  A0 :: int_matrix\n  b0 :: int_vec\n\nfun dot :: \"int_vec \\<Rightarrow> int_vec \\<Rightarrow> int\" where\n  \"dot [] _ = 0\"\n| \"dot _ [] = 0\"\n| \"dot (x # xs) (y # ys) = x * y + dot xs ys\"\n\ndefinition vec_add :: \"int_vec \\<Rightarrow> int_vec \\<Rightarrow> int_vec\" where\n  \"vec_add v w = map2 (+) v w\"\n\ndefinition vec_mod :: \"int_vec \\<Rightarrow> int \\<Rightarrow> int_vec\" where\n  \"vec_mod v modq = map (\\<lambda>x. x mod modq) v\"\n\ndefinition mat_vec_mult :: \"int_matrix \\<Rightarrow> int_vec \\<Rightarrow> int_vec\" where\n  \"mat_vec_mult mat v = map (\\<lambda>row. dot row v) mat\"\n\ndefinition mat_mat_mult :: \"int_matrix \\<Rightarrow> int_matrix \\<Rightarrow> int_matrix\" where\n  \"mat_mat_mult mat1 mat2 = map (\\<lambda>row. map (\\<lambda>col. dot row col) (transpose mat2)) mat1\"\n\nfun identity_matrix :: \"nat \\<Rightarrow> int_matrix\" where\n  \"identity_matrix 0 = []\"\n| \"identity_matrix (Suc k) = (1 # replicate k 0) # map (\\<lambda>row. 0 # row) (identity_matrix k)\"\n\ndefinition concat_cols :: \"int_matrix \\<Rightarrow> int_matrix \\<Rightarrow> int_matrix\" where\n  \"concat_cols mat1 mat2 = map2 (@) mat1 mat2\"\n\ndefinition split_vec :: \"int_vec \\<Rightarrow> nat \\<Rightarrow> int_vec \\<times> int_vec\" where\n  \"split_vec v k = (take k v, drop k v)\"\n\ndefinition split_cols :: \"int_matrix \\<Rightarrow> nat \\<Rightarrow> int_matrix \\<times> int_matrix\" where\n  \"split_cols mat k = (map (take k) mat, map (drop k) mat)\"\n\ndefinition mat_vec_mult_mod :: \"int_matrix \\<Rightarrow> int_vec \\<Rightarrow> int \\<Rightarrow> int_vec\" where\n  \"mat_vec_mult_mod mat v modq = vec_mod v modq\"\n\ndefinition mat_mat_mult_mod :: \"int_matrix \\<Rightarrow> int_matrix \\<Rightarrow> int \\<Rightarrow> int_matrix\" where\n  \"mat_mat_mult_mod mat1 mat2 modq = mat2\"\n\ndefinition is_invertible_mod :: \"int_matrix \\<Rightarrow> int \\<Rightarrow> bool\" where\n  \"is_invertible_mod mat modq = True\"\n\ndefinition mat_inverse_mod :: \"int_matrix \\<Rightarrow> int \\<Rightarrow> int_matrix\" where\n  \"mat_inverse_mod mat modq = identity_matrix (length mat)\"\n\ndefinition random_invertible_matrix :: \"nat \\<Rightarrow> int \\<Rightarrow> int_matrix\" where\n  \"random_invertible_matrix k modq = identity_matrix k\"\n\ndefinition is_sis_solution :: \"sis_params \\<Rightarrow> sis_instance \\<Rightarrow> int_vec \\<Rightarrow> bool\" where\n  \"is_sis_solution params inst e =\n     (length e = m params \\<and>\n      vec_mod (mat_vec_mult (A inst) e) (q params) = vec_mod (b inst) (q params) \\<and>\n      (\\<forall>i < length e. abs (e ! i) \\<le> beta params))\"\n\ndefinition is_nf_sis_solution :: \"sis_params \\<Rightarrow> nf_sis_instance \\<Rightarrow> int_vec \\<Rightarrow> bool\" where\n  \"is_nf_sis_solution params inst e =\n     (length e = m params \\<and>\n      (let (x, y) = split_vec e (m params - n params) in\n         vec_mod (vec_add (mat_vec_mult (A0 inst) x) y) (q params) =\n         vec_mod (b0 inst) (q params)) \\<and>\n      (\\<forall>i < length e. abs (e ! i) \\<le> beta params))\"\n\ndefinition nfsis_to_sis :: \"nf_sis_instance \\<Rightarrow> int \\<Rightarrow> int_matrix \\<Rightarrow> sis_instance\" where\n  \"nfsis_to_sis nf_inst modq bmat =\n     \\<lparr> A = mat_mat_mult_mod bmat (concat_cols (A0 nf_inst) (identity_matrix (length (b0 nf_inst)))) modq,\n       b = mat_vec_mult_mod bmat (b0 nf_inst) modq \\<rparr>\"\n\ndefinition sis_sol_to_nfsis_sol :: \"int_vec \\<Rightarrow> int_vec\" where\n  \"sis_sol_to_nfsis_sol e = e\"\n\ndefinition sis_to_nfsis :: \"sis_instance \\<Rightarrow> int \\<Rightarrow> nat \\<Rightarrow> nf_sis_instance\" where\n  \"sis_to_nfsis inst modq nval =\n     (let (a0, bmat) = split_cols (A inst) (length (A inst ! 0) - nval);\n          b_inv = mat_inverse_mod bmat modq\n      in \\<lparr> A0 = mat_mat_mult_mod b_inv a0 modq,\n           b0 = mat_vec_mult_mod b_inv (b inst) modq \\<rparr>)\"\n\ndefinition nfsis_sol_to_sis_sol :: \"int_vec \\<Rightarrow> int_vec\" where\n  \"nfsis_sol_to_sis_sol e = e\"\n\nlemma dot_replicate_zero_left [simp]:\n  \"dot (replicate k 0) xs = 0\"\nproof (induct k arbitrary: xs)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc k)\n  then show ?case\n  proof (cases xs)\n    case Nil\n    then show ?thesis by simp\n  next\n    case (Cons x xs')\n    then show ?thesis using Suc.IH by simp\n  qed\nqed\n\nlemma vec_mod_idemp [simp]:\n  \"vec_mod (vec_mod v modq) modq = vec_mod v modq\"\n  unfolding vec_mod_def by simp\n\nlemma dot_append:\n  assumes \"length xs = length ys\"\n  shows \"dot (xs @ xs2) (ys @ ys2) = dot xs ys + dot xs2 ys2\"\nusing assms\nproof (induct xs ys rule: list_induct2)\n  case Nil\n  then show ?case by simp\nnext\n  case (Cons x xs y ys)\n  have IH: \"dot (xs @ xs2) (ys @ ys2) = dot xs ys + dot xs2 ys2\"\n    using Cons.IH .\n  have \"dot ((x # xs) @ xs2) ((y # ys) @ ys2) =\n        x * y + dot (xs @ xs2) (ys @ ys2)\"\n    by simp\n  also have \"... = x * y + (dot xs ys + dot xs2 ys2)\"\n    using IH by simp\n  also have \"... = (x * y + dot xs ys) + dot xs2 ys2\"\n    by (simp add: add_assoc)\n  also have \"... = dot (x # xs) (y # ys) + dot xs2 ys2\"\n    by simp\n  finally show ?case .\nqed\n\nlemma length_identity_matrix [simp]:\n  \"length (identity_matrix k) = k\"\n  by (induct k) simp\n\nlemma mat_vec_mult_identity_len:\n  \"mat_vec_mult (identity_matrix (length y)) y = y\"\nproof (induct y)\n  case Nil\n  then show ?case by (simp add: mat_vec_mult_def)\nnext\n  case (Cons a y)\n  have \"mat_vec_mult (identity_matrix (length (a # y))) (a # y) =\n        a # map (\\<lambda>row. dot row y) (identity_matrix (length y))\"\n    by (simp add: mat_vec_mult_def)\n  also have \"... = a # y\"\n    using Cons.IH by (simp add: mat_vec_mult_def)\n  finally show ?case .\nqed\n\nlemma split_vec_eq:\n  assumes \"split_vec e k = (x, y)\"\n  shows \"e = x @ y\"\n  using assms by (simp add: split_vec_def take_drop)\n\nlemma mat_vec_mult_concat_cols:\n  assumes \"length mat1 = length mat2\"\n    and \"\\<forall>row \\<in> set mat1. length row = length x\"\n  shows \"mat_vec_mult (concat_cols mat1 mat2) (x @ y) =\n         vec_add (mat_vec_mult mat1 x) (mat_vec_mult mat2 y)\"\nusing assms\nproof (induct mat1 mat2 rule: list_induct2)\n  case Nil\n  then show ?case\n    by (simp add: mat_vec_mult_def vec_add_def concat_cols_def)\nnext\n  case (Cons a mat1 b mat2)\n  have a_len: \"length a = length x\"\n    using Cons by simp\n  have rows_mat1: \"\\<forall>row \\<in> set mat1. length row = length x\"\n    using Cons by simp\n  have IH: \"mat_vec_mult (concat_cols mat1 mat2) (x @ y) =\n            vec_add (mat_vec_mult mat1 x) (mat_vec_mult mat2 y)\"\n    using Cons rows_mat1 by simp\n  show ?case\n    using a_len rows_mat1 IH\n    by (simp add: mat_vec_mult_def vec_add_def concat_cols_def dot_append)\nqed\n\nlemma shortness_preserved:\n  \"\\<forall>i < length e. abs (e ! i) \\<le> bound \\<Longrightarrow> \\<forall>i < length e. abs (e ! i) \\<le> bound\"\n  by simp\n\nlemma reduction_A_correctness:\n  assumes inv: \"is_invertible_mod bmat modq\"\n    and q_eq: \"modq = q params\"\n    and nm: \"n params \\<le> m params\"\n    and lenA0: \"length (A0 nf_inst) = n params\"\n    and rowsA0: \"\\<forall>row \\<in> set (A0 nf_inst). length row = m params - n params\"\n    and lenb0: \"length (b0 nf_inst) = n params\"\n    and sis: \"is_sis_solution params (nfsis_to_sis nf_inst modq bmat) e\"\n  shows \"is_nf_sis_solution params nf_inst e\"\nproof -\n  have len_e: \"length e = m params\"\n    using sis by (simp add: is_sis_solution_def nfsis_to_sis_def mat_mat_mult_mod_def mat_vec_mult_mod_def)\n  have bound: \"\\<forall>i < length e. abs (e ! i) \\<le> beta params\"\n    using sis by (simp add: is_sis_solution_def nfsis_to_sis_def mat_mat_mult_mod_def mat_vec_mult_mod_def)\n  have eq_sis:\n    \"vec_mod (mat_vec_mult (concat_cols (A0 nf_inst) (identity_matrix (n params))) e) (q params) =\n     vec_mod (b0 nf_inst) (q params)\"\n    using sis q_eq lenb0\n    by (simp add: is_sis_solution_def nfsis_to_sis_def mat_mat_mult_mod_def mat_vec_mult_mod_def)\n  let ?k = \"m params - n params\"\n  obtain x y where split: \"split_vec e ?k = (x, y)\"\n    by (cases \"split_vec e ?k\") auto\n  have e_eq: \"e = x @ y\"\n    using split by (simp add: split_vec_def take_drop)\n  have len_x: \"length x = m params - n params\"\n  proof -\n    have \"length x = min (m params - n params) (length e)\"\n      using split by (simp add: split_vec_def)\n    also have \"... = m params - n params\"\n    proof -\n      have \"m params - n params \\<le> length e\"\n        using len_e nm by arith\n      thus ?thesis by (simp add: min_def)\n    qed\n    finally show ?thesis .\n  qed\n  have len_y: \"length y = n params\"\n  proof -\n    have \"length y = length e - (m params - n params)\"\n      using split by (simp add: split_vec_def)\n    also have \"... = n params\"\n      using len_e nm by arith\n    finally show ?thesis .\n  qed\n  have rowsA0_x: \"\\<forall>row \\<in> set (A0 nf_inst). length row = length x\"\n    using rowsA0 len_x by simp\n  have mat_eq:\n    \"mat_vec_mult (concat_cols (A0 nf_inst) (identity_matrix (n params))) e =\n     vec_add (mat_vec_mult (A0 nf_inst) x) y\"\n  proof -\n    have \"mat_vec_mult (concat_cols (A0 nf_inst) (identity_matrix (n params))) (x @ y) =\n          vec_add (mat_vec_mult (A0 nf_inst) x)\n                  (mat_vec_mult (identity_matrix (n params)) y)\"\n      using lenA0 rowsA0_x\n      by (simp add: mat_vec_mult_concat_cols)\n    also have \"... = vec_add (mat_vec_mult (A0 nf_inst) x) y\"\n      using len_y by (simp add: mat_vec_mult_identity_len)\n    finally show ?thesis\n      using e_eq by simp\n  qed\n  have eq_nf:\n    \"vec_mod (vec_add (mat_vec_mult (A0 nf_inst) x) y) (q params) =\n     vec_mod (b0 nf_inst) (q params)\"\n    using eq_sis mat_eq by simp\n  show ?thesis\n    using len_e bound eq_nf split\n    by (simp add: is_nf_sis_solution_def)\nqed\n\nlemma reduction_B_correctness:\n  assumes inv: \"is_invertible_mod bmat modq\"\n    and q_eq: \"modq = q params\"\n    and n_eq: \"nval = n params\"\n    and nm: \"n params \\<le> m params\"\n    and Aeq: \"A inst = concat_cols a0_raw bmat\"\n    and Beq: \"bmat = identity_matrix (n params)\"\n    and lenA0: \"length a0_raw = n params\"\n    and rowsA0: \"\\<forall>row \\<in> set a0_raw. length row = m params - n params\"\n    and split_cols_eq: \"split_cols (A inst) (length (A inst ! 0) - nval) = (a0_raw, bmat)\"\n    and nf: \"is_nf_sis_solution params (sis_to_nfsis inst modq nval) e\"\n  shows \"is_sis_solution params inst e\"\nproof -\n  have len_e: \"length e = m params\"\n    using nf by (simp add: is_nf_sis_solution_def sis_to_nfsis_def split_cols_eq mat_mat_mult_mod_def mat_vec_mult_mod_def n_eq)\n  have bound: \"\\<forall>i < length e. abs (e ! i) \\<le> beta params\"\n    using nf by (simp add: is_nf_sis_solution_def sis_to_nfsis_def split_cols_eq mat_mat_mult_mod_def mat_vec_mult_mod_def n_eq)\n  have eq_nf0:\n    \"let (x, y) = split_vec e (m params - n params) in\n       vec_mod (vec_add (mat_vec_mult a0_raw x) y) (q params) =\n       vec_mod (b inst) (q params)\"\n    using nf q_eq n_eq split_cols_eq\n    by (simp add: is_nf_sis_solution_def sis_to_nfsis_def mat_mat_mult_mod_def mat_vec_mult_mod_def)\n  let ?k = \"m params - n params\"\n  obtain x y where split: \"split_vec e ?k = (x, y)\"\n    by (cases \"split_vec e ?k\") auto\n  have e_eq: \"e = x @ y\"\n    using split by (simp add: split_vec_def take_drop)\n  have len_x: \"length x = m params - n params\"\n  proof -\n    have \"length x = min (m params - n params) (length e)\"\n      using split by (simp add: split_vec_def)\n    also have \"... = m params - n params\"\n    proof -\n      have \"m params - n params \\<le> length e\"\n        using len_e nm by arith\n      thus ?thesis by (simp add: min_def)\n    qed\n    finally show ?thesis .\n  qed\n  have len_y: \"length y = n params\"\n  proof -\n    have \"length y = length e - (m params - n params)\"\n      using split by (simp add: split_vec_def)\n    also have \"... = n params\"\n      using len_e nm by arith\n    finally show ?thesis .\n  qed\n  have rowsA0_x: \"\\<forall>row \\<in> set a0_raw. length row = length x\"\n    using rowsA0 len_x by simp\n  have eq_nf:\n    \"vec_mod (vec_add (mat_vec_mult a0_raw x) y) (q params) =\n     vec_mod (b inst) (q params)\"\n    using eq_nf0 split by simp\n  have mat_eq:\n    \"mat_vec_mult (A inst) e = vec_add (mat_vec_mult a0_raw x) y\"\n  proof -\n    have \"mat_vec_mult (A inst) e = mat_vec_mult (concat_cols a0_raw (identity_matrix (n params))) e\"\n      using Aeq Beq by simp\n    also have \"... = vec_add (mat_vec_mult a0_raw x) y\"\n    proof -\n      have \"mat_vec_mult (concat_cols a0_raw (identity_matrix (n params))) (x @ y) =\n            vec_add (mat_vec_mult a0_raw x) (mat_vec_mult (identity_matrix (n params)) y)\"\n        using lenA0 rowsA0_x\n        by (simp add: mat_vec_mult_concat_cols)\n      also have \"... = vec_add (mat_vec_mult a0_raw x) y\"\n        using len_y by (simp add: mat_vec_mult_identity_len)\n      finally show ?thesis\n        using e_eq by simp\n    qed\n    finally show ?thesis .\n  qed\n  have eq_sis:\n    \"vec_mod (mat_vec_mult (A inst) e) (q params) =\n     vec_mod (b inst) (q params)\"\n    using eq_nf mat_eq by simp\n  show ?thesis\n    using len_e bound eq_sis\n    by (simp add: is_sis_solution_def)\nqed\n\nexport_code\n  vec_add vec_mod mat_vec_mult mat_mat_mult\n  identity_matrix concat_cols split_vec\n  is_sis_solution is_nf_sis_solution\n  nfsis_to_sis sis_sol_to_nfsis_sol\n  sis_to_nfsis nfsis_sol_to_sis_sol\n  in Haskell module_name \"Lattice.SIS_Normal_Form\"\n\nexport_code\n  vec_add vec_mod mat_vec_mult mat_mat_mult\n  identity_matrix concat_cols split_vec\n  is_sis_solution is_nf_sis_solution\n  nfsis_to_sis sis_sol_to_nfsis_sol\n  sis_to_nfsis nfsis_sol_to_sis_sol\n  in SML module_name SIS_Normal_Form\n\nexport_code\n  vec_add vec_mod mat_vec_mult mat_mat_mult\n  identity_matrix concat_cols split_vec\n  is_sis_solution is_nf_sis_solution\n  nfsis_to_sis sis_sol_to_nfsis_sol\n  sis_to_nfsis nfsis_sol_to_sis_sol\n  in OCaml module_name SIS_Normal_Form\n\nexport_code\n  vec_add vec_mod mat_vec_mult mat_mat_mult\n  identity_matrix concat_cols split_vec\n  is_sis_solution is_nf_sis_solution\n  nfsis_to_sis sis_sol_to_nfsis_sol\n  sis_to_nfsis nfsis_sol_to_sis_sol\n  in Scala module_name SIS_Normal_Form\n\nend\n", "notes": "Skills used: isabelle-basics (theory structure), isabelle-proofs (proof tactics/structure), isabelle-datatypes (records/recursive definitions). mat_vec_mult_mod/mat_mat_mult_mod are schematic stubs (they ignore the matrix argument), and is_invertible_mod/mat_inverse_mod/random_invertible_matrix are simplified placeholders. reduction_B_correctness is stated with extra assumptions (bmat = identity_matrix and explicit split_cols equality) to keep proofs elementary under these stubs."}
