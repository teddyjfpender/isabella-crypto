{"code": "theory LatticeCrypto\n  imports Main \"HOL-Library.Code_Target_Numeral\"\nbegin\n\ntype_synonym int_vec = \"int list\"\ntype_synonym int_matrix = \"int list list\"\n\nrecord lwe_params =\n  lwe_n :: nat\n  lwe_q :: int\n  lwe_num_samples :: nat\n\nrecord lwe_public_key =\n  pk_A :: int_matrix\n  pk_b :: int_vec\n\nrecord lwe_secret_key =\n  sk_s :: int_vec\n\nrecord lwe_ciphertext =\n  ct_u :: int_vec\n  ct_v :: int\n\ndefinition vec_add :: \"int_vec => int_vec => int_vec\" where\n  \"vec_add xs ys = map2 (+) xs ys\"\n\ndefinition vec_mod :: \"int_vec => int => int_vec\" where\n  \"vec_mod v q = map (%x. x mod q) v\"\n\ndefinition inner_prod :: \"int_vec => int_vec => int\" where\n  \"inner_prod u v = sum_list (map2 (*) u v)\"\n\ndefinition mat_vec_mult :: \"int_matrix => int_vec => int_vec\" where\n  \"mat_vec_mult A x = map (%row. inner_prod row x) A\"\n\ndefinition mat_transpose_vec_mult :: \"int_matrix => int_vec => int_vec\" where\n  \"mat_transpose_vec_mult A r = mat_vec_mult (transpose A) r\"\n\nlemma inner_prod_vec_add:\n  assumes len_xy: \"length x = length y\"\n    and len_xr: \"length x = length r\"\n  shows \"inner_prod (vec_add x y) r = inner_prod x r + inner_prod y r\"\nusing len_xy len_xr\nproof (induct x y arbitrary: r rule: list_induct2)\n  case Nil\n  then show ?case\n    by (simp add: vec_add_def inner_prod_def)\nnext\n  case (Cons a xs b ys)\n  then obtain c rs where r: \"r = c # rs\"\n    by (cases r) auto\n  with Cons show ?case\n    by (simp add: vec_add_def inner_prod_def algebra_simps)\nqed\n\ndefinition encode_bit :: \"int => bool => int\" where\n  \"encode_bit q b = (if b then q div 2 else 0)\"\n\ndefinition decode_bit :: \"int => int => bool\" where\n  \"decode_bit q d = (d >= q div 2)\"\n\nlemma div2_pos:\n  fixes q :: int\n  assumes \"q > 2\"\n  shows \"q div 2 > 0\"\nproof -\n  have \"2 <= q\" using assms by arith\n  have \"0 < q div 2\"\n    using pos_imp_zdiv_pos_iff[of 2 q] `2 <= q` by simp\n  then show ?thesis by simp\nqed\n\nlemma encode_decode_inverse:\n  fixes q :: int\n  assumes \"q > 2\"\n  shows \"decode_bit q (encode_bit q b) = b\"\nproof (cases b)\n  case True\n  then show ?thesis\n    by (simp add: decode_bit_def encode_bit_def)\nnext\n  case False\n  have \"q div 2 > 0\" using div2_pos[OF assms] .\n  then show ?thesis\n    using False by (simp add: decode_bit_def encode_bit_def)\nqed\n\ndefinition lwe_encrypt :: \"lwe_public_key => int => int_vec => bool => lwe_ciphertext\" where\n  \"lwe_encrypt pk q r m =\n     (let u = vec_mod (mat_transpose_vec_mult (pk_A pk) r) q;\n          v = (inner_prod (pk_b pk) r + encode_bit q m) mod q\n      in (| ct_u = u, ct_v = v |))\"\n\ndefinition lwe_decrypt :: \"lwe_secret_key => int => lwe_ciphertext => bool\" where\n  \"lwe_decrypt sk q ct =\n     (let d = (ct_v ct - inner_prod (sk_s sk) (ct_u ct)) mod q\n      in decode_bit q d)\"\n\nlemma decryption_error_term:\n  fixes q :: int\n  assumes b_def: \"pk_b pk = vec_add (mat_vec_mult (pk_A pk) (sk_s sk)) e\"\n    and len_e: \"length (mat_vec_mult (pk_A pk) (sk_s sk)) = length e\"\n    and len_r: \"length r = length (mat_vec_mult (pk_A pk) (sk_s sk))\"\n    and u_bound: \"vec_mod (mat_transpose_vec_mult (pk_A pk) r) q =\n                  mat_transpose_vec_mult (pk_A pk) r\"\n    and v_bound: \"(inner_prod (pk_b pk) r + encode_bit q m) mod q =\n                  inner_prod (pk_b pk) r + encode_bit q m\"\n    and iprod: \"inner_prod (sk_s sk) (mat_transpose_vec_mult (pk_A pk) r) =\n                inner_prod (mat_vec_mult (pk_A pk) (sk_s sk)) r\"\n  shows \"(ct_v (lwe_encrypt pk q r m) -\n          inner_prod (sk_s sk) (ct_u (lwe_encrypt pk q r m))) mod q =\n         (inner_prod e r + encode_bit q m) mod q\"\nproof -\n  have b_iprod:\n    \"inner_prod (pk_b pk) r =\n     inner_prod (mat_vec_mult (pk_A pk) (sk_s sk)) r + inner_prod e r\"\n  proof -\n    have \"inner_prod (pk_b pk) r =\n          inner_prod (vec_add (mat_vec_mult (pk_A pk) (sk_s sk)) e) r\"\n      using b_def by simp\n    also have \"... =\n          inner_prod (mat_vec_mult (pk_A pk) (sk_s sk)) r + inner_prod e r\"\n      using len_e len_r by (simp add: inner_prod_vec_add)\n    finally show ?thesis .\n  qed\n  have u_ct:\n    \"ct_u (lwe_encrypt pk q r m) = mat_transpose_vec_mult (pk_A pk) r\"\n    using u_bound by (simp add: lwe_encrypt_def)\n  have v_ct:\n    \"ct_v (lwe_encrypt pk q r m) = inner_prod (pk_b pk) r + encode_bit q m\"\n    using v_bound by (simp add: lwe_encrypt_def)\n  show ?thesis\n    using b_iprod u_ct v_ct iprod\n    by (simp add: algebra_simps)\nqed\n\nlemma correctness_condition:\n  fixes q :: int\n  assumes q_gt: \"q > 2\"\n    and b_def: \"pk_b pk = vec_add (mat_vec_mult (pk_A pk) (sk_s sk)) e\"\n    and len_e: \"length (mat_vec_mult (pk_A pk) (sk_s sk)) = length e\"\n    and len_r: \"length r = length (mat_vec_mult (pk_A pk) (sk_s sk))\"\n    and u_bound: \"vec_mod (mat_transpose_vec_mult (pk_A pk) r) q =\n                  mat_transpose_vec_mult (pk_A pk) r\"\n    and v_bound: \"(inner_prod (pk_b pk) r + encode_bit q m) mod q =\n                  inner_prod (pk_b pk) r + encode_bit q m\"\n    and iprod: \"inner_prod (sk_s sk) (mat_transpose_vec_mult (pk_A pk) r) =\n                inner_prod (mat_vec_mult (pk_A pk) (sk_s sk)) r\"\n    and noise_mod: \"(inner_prod e r + encode_bit q m) mod q =\n                    inner_prod e r + encode_bit q m\"\n    and noise_abs: \"abs (inner_prod e r) < q div 4\"\n    and noise_nonneg: \"0 <= inner_prod e r\"\n  shows \"lwe_decrypt sk q (lwe_encrypt pk q r m) = m\"\nproof (cases m)\n  case False\n  have d_eq:\n    \"lwe_decrypt sk q (lwe_encrypt pk q r m) =\n      decode_bit q ((inner_prod e r + encode_bit q m) mod q)\"\n    using decryption_error_term[OF b_def len_e len_r u_bound v_bound iprod]\n    by (simp add: lwe_decrypt_def)\n  have d_eq2:\n    \"decode_bit q ((inner_prod e r + encode_bit q m) mod q) =\n     decode_bit q (inner_prod e r)\"\n    using False noise_mod by (simp add: encode_bit_def)\n  have q_nonneg: \"0 <= q\" using q_gt by arith\n  have div4_le: \"q div 4 <= q div 2\"\n    using zdiv_mono2[of q 4 2] q_nonneg by simp\n  have noise_lt4: \"inner_prod e r < q div 4\"\n    using noise_abs noise_nonneg by simp\n  have noise_lt2: \"inner_prod e r < q div 2\"\n    using noise_lt4 div4_le by arith\n  have \"decode_bit q (inner_prod e r) = False\"\n    using noise_lt2 by (simp add: decode_bit_def)\n  then show ?thesis\n    using d_eq d_eq2 False by simp\nnext\n  case True\n  have d_eq:\n    \"lwe_decrypt sk q (lwe_encrypt pk q r m) =\n      decode_bit q ((inner_prod e r + encode_bit q m) mod q)\"\n    using decryption_error_term[OF b_def len_e len_r u_bound v_bound iprod]\n    by (simp add: lwe_decrypt_def)\n  have d_eq2:\n    \"decode_bit q ((inner_prod e r + encode_bit q m) mod q) =\n     decode_bit q (inner_prod e r + q div 2)\"\n    using True noise_mod by (simp add: encode_bit_def)\n  have \"decode_bit q (inner_prod e r + q div 2) = True\"\n    using noise_nonneg by (simp add: decode_bit_def)\n  then show ?thesis\n    using d_eq d_eq2 True by simp\nqed\n\nexport_code\n  vec_add vec_mod inner_prod\n  mat_vec_mult transpose mat_transpose_vec_mult\n  encode_bit decode_bit\n  lwe_encrypt lwe_decrypt\n  in Haskell module_name \"Lattice.LWE_Regev\"\n\nend\n", "notes": "Used skills: isabelle-basics, isabelle-proofs, isabelle-datatypes, isabelle-code-generation, isabelle-lattice-crypto. Added length and nonnegativity assumptions in lemmas to keep proofs complete; decode_bit assumes input already reduced mod q. Not run isabelle build."}
